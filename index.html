<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Topdown Sword Swarm</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <style>
    body { margin: 0; background: #111; }
    canvas { display: block; margin: 0 auto; touch-action: none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.0/dist/phaser.js"></script>
</head>
<body>

<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: "#202020",
  physics: {
    default: "arcade",
    arcade: { debug: false }
  },
  scene: { preload, create, update }
};

let game = new Phaser.Game(config);

let player, monsters, swordHitbox;
let score = 0, scoreText;

let cursors;
let joyBase, joyThumb;
let joyPointer = null;
let joyRadius = 60;
let moveVector = { x: 0, y: 0 };

let attackBtn;
let attacking = false;
let canAttack = true;

function preload() {}

function create() {
  const g = this.add.graphics();

  // player: blue square
  g.fillStyle(0x3399ff, 1);
  g.fillRect(0, 0, 32, 32);
  g.generateTexture("playerBlue", 32, 32);
  g.clear();

  // monster: red square
  g.fillStyle(0xff3333, 1);
  g.fillRect(0, 0, 26, 26);
  g.generateTexture("monsterRed", 26, 26);
  g.clear();

  // sword hitbox: yellow rectangle
  g.fillStyle(0xffff00, 0.6);
  g.fillRect(0, 0, 32, 16);
  g.generateTexture("swordBox", 32, 16);
  g.clear();

  // joystick base + thumb [web:145][web:148]
  g.fillStyle(0xffffff, 0.15);
  g.fillCircle(70, 530, 40);
  g.generateTexture("joyBase", 140, 140);
  g.clear();

  g.fillStyle(0xffffff, 0.4);
  g.fillCircle(0, 0, 25);
  g.generateTexture("joyThumb", 50, 50);
  g.destroy();

  // player
  player = this.physics.add.sprite(400, 300, "playerBlue");
  player.setCollideWorldBounds(true);
  player.speed = 200;
  player.facing = "down";

  // sword hitbox (invisible unless attacking)
  swordHitbox = this.physics.add.image(player.x, player.y, "swordBox");
  swordHitbox.setVisible(false);
  swordHitbox.body.enable = false;

  // monsters
  monsters = this.physics.add.group();
  spawnMonsters.call(this, 6);

  // keyboard for desktop
  cursors = this.input.keyboard.createCursorKeys();

  // score
  scoreText = this.add.text(10, 10, "Score: 0", { font: "20px Arial", fill: "#ffffff" });
  this.add.text(10, 35, "Move: Joystick or Arrows | Attack: Button", { font: "14px Arial", fill: "#ffffff" });

  // sword vs monsters
  this.physics.add.overlap(swordHitbox, monsters, (s, m) => {
    if (!attacking) return;
    m.destroy();
    score++;
    scoreText.setText("Score: " + score);
    if (monsters.countActive(true) === 0) {
      spawnMonsters.call(this, 6 + Math.floor(score / 3));
    }
  });

  // monsters vs player
  this.physics.add.overlap(player, monsters, () => {
    score = 0;
    this.scene.restart();
  });

  // === VIRTUAL JOYSTICK === [web:145][web:148]
  joyBase = this.add.circle(80, 520, 40, 0xffffff, 0.1).setScrollFactor(0);
  joyThumb = this.add.circle(80, 520, 20, 0xffffff, 0.5).setScrollFactor(0);
  joyBase.setInteractive();

  joyBase.on("pointerdown", (pointer) => {
    joyPointer = pointer.id;
    joyThumb.x = pointer.x;
    joyThumb.y = pointer.y;
    joyBase.x = pointer.x;
    joyBase.y = pointer.y;
  });

  this.input.on("pointermove", (pointer) => {
    if (joyPointer === pointer.id) {
      const dx = pointer.x - joyBase.x;
      const dy = pointer.y - joyBase.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const max = joyRadius;

      let nx = dx;
      let ny = dy;
      if (dist > max && dist !== 0) {
        nx = (dx / dist) * max;
        ny = (dy / dist) * max;
      }

      joyThumb.x = joyBase.x + nx;
      joyThumb.y = joyBase.y + ny;

      moveVector.x = nx / max;
      moveVector.y = ny / max;
    }
  });

  this.input.on("pointerup", (pointer) => {
    if (joyPointer === pointer.id) {
      joyPointer = null;
      moveVector.x = 0;
      moveVector.y = 0;
      joyBase.x = 80;
      joyBase.y = 520;
      joyThumb.x = 80;
      joyThumb.y = 520;
    }
  });

  // === ATTACK BUTTON ===
  attackBtn = this.add.rectangle(720, 520, 80, 80, 0xffcc00, 0.4)
    .setScrollFactor(0)
    .setInteractive();
  this.add.text(702, 505, "SWING", { font: "18px Arial", fill: "#000000" }).setScrollFactor(0);

  attackBtn.on("pointerdown", () => {
    tryAttack.call(this);
  });

  // also allow SPACE on keyboard for attack
  this.input.keyboard.on("keydown-SPACE", () => {
    tryAttack.call(this);
  });
}

function update(time, delta) {
  handleMovement(delta);
  updateSwordHitbox();
  moveMonsters();
}

// movement from joystick + keyboard [web:57][web:145]
function handleMovement(delta) {
  player.setVelocity(0);

  // keyboard
  if (cursors.left && cursors.left.isDown) player.setVelocityX(-player.speed);
  if (cursors.right && cursors.right.isDown) player.setVelocityX(player.speed);
  if (cursors.up && cursors.up.isDown) player.setVelocityY(-player.speed);
  if (cursors.down && cursors.down.isDown) player.setVelocityY(player.speed);

  // joystick
  if (moveVector.x !== 0 || moveVector.y !== 0) {
    player.setVelocity(moveVector.x * player.speed, moveVector.y * player.speed);
  }

  // update facing based on last movement
  if (player.body.velocity.lengthSq() > 0) {
    const vx = player.body.velocity.x;
    const vy = player.body.velocity.y;
    if (Math.abs(vx) > Math.abs(vy)) {
      player.facing = vx > 0 ? "right" : "left";
    } else {
      player.facing = vy > 0 ? "down" : "up";
    }
  }
}

function tryAttack() {
  if (!canAttack) return;
  canAttack = false;
  attacking = true;

  swordHitbox.setVisible(true);
  swordHitbox.body.enable = true;

  // end attack after a short time [web:162][web:166]
  this.time.delayedCall(200, () => {
    attacking = false;
    swordHitbox.setVisible(false);
    swordHitbox.body.enable = false;
  });

  // cooldown
  this.time.delayedCall(300, () => {
    canAttack = true;
  });
}

function updateSwordHitbox() {
  swordHitbox.x = player.x;
  swordHitbox.y = player.y;

  // position in front of player based on facing
  const offset = 24;
  if (player.facing === "right") {
    swordHitbox.angle = 0;
    swordHitbox.x = player.x + offset;
    swordHitbox.y = player.y;
  } else if (player.facing === "left") {
    swordHitbox.angle = 180;
    swordHitbox.x = player.x - offset;
    swordHitbox.y = player.y;
  } else if (player.facing === "up") {
    swordHitbox.angle = -90;
    swordHitbox.x = player.x;
    swordHitbox.y = player.y - offset;
  } else {
    swordHitbox.angle = 90;
    swordHitbox.x = player.x;
    swordHitbox.y = player.y + offset;
  }
}

function spawnMonsters(count) {
  monsters.clear(true, true);
  for (let i = 0; i < count; i++) {
    const edge = Phaser.Math.Between(0, 3);
    let x, y;
    if (edge === 0) { x = Phaser.Math.Between(0, 800); y = -30; }
    else if (edge === 1) { x = 830; y = Phaser.Math.Between(0, 600); }
    else if (edge === 2) { x = Phaser.Math.Between(0, 800); y = 630; }
    else { x = -30; y = Phaser.Math.Between(0, 600); }

    const m = monsters.create(x, y, "monsterRed");
    m.speed = 60 + score * 3; // faster as score goes up [web:61]
  }
}

// monsters swarm toward player [web:61][web:76]
function moveMonsters() {
  monsters.children.iterate(m => {
    if (!m || !m.active) return;
    const angle = Phaser.Math.Angle.Between(m.x, m.y, player.x, player.y);
    const vx = Math.cos(angle) * m.speed;
    const vy = Math.sin(angle) * m.speed;
    m.setVelocity(vx, vy);
  });
}
</script>

</body>
</html>
